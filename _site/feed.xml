<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="https://blamster19.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blamster19.github.io/" rel="alternate" type="text/html" /><updated>2023-09-13T20:38:24+00:00</updated><id>https://blamster19.github.io/feed.xml</id><title type="html">blamster19 - all stuff blamster</title><subtitle>blamster19&apos;s little corner of the Net.</subtitle><entry><title type="html">DIY Raspberry Pi ebook reader, part 2 - setting things up</title><link href="https://blamster19.github.io/2023/09/13/rpi-ebook-2.html" rel="alternate" type="text/html" title="DIY Raspberry Pi ebook reader, part 2 - setting things up" /><published>2023-09-13T20:38:05+00:00</published><updated>2023-09-13T20:38:18+00:00</updated><id>https://blamster19.github.io/2023/09/13/rpi-ebook-2</id><content type="html" xml:base="https://blamster19.github.io/2023/09/13/rpi-ebook-2.html">&lt;h1 id=&quot;body-and-mind&quot;&gt;Body and mind&lt;/h1&gt;

&lt;p&gt;Since I have now acquired all the hardware I wanted, I can learn to use it and make something great. Before I delve into designing interface, I must first install required software and check the physical layer for any issues.&lt;/p&gt;

&lt;h1 id=&quot;prepping-raspberry-pi&quot;&gt;Prepping Raspberry Pi&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.raspberrypi.com/products/raspberry-pi-zero-w/&quot;&gt;Raspberry Pi Zero W&lt;/a&gt; is an SBC which supports full operating systems, in contrast to other popular hobbyist platform Arduino. The usual way of doing things is to install &lt;a href=&quot;https://www.raspberrypi.com/software/&quot;&gt;Raspberry Pi OS&lt;/a&gt; (formerly Raspbian; I liked that name better, shame they changed that), an official dedicated Debian GNU/Linux based distro with a wealth of programs available in its repository. This is an excellent choice for people who do not wish to spend hours fiddling with stuff and who do not care about conserving resources to the extreme while sacrificing their sanity. Obviously this is not me, so I started looking for other things to put in my Pi.&lt;br /&gt;
The first thing to come to my mind was BSD. This family of OSes is not exactly known to be the first choice for Raspberry Pi, and I have never actually encountered a project using one. I have never used BSD before, so I was thrilled by the prospect of learning alien system in, I believe, quite niche setup. But then I began to worry about driver support - I have custom hardware to connect, and vendor libraries are mostly written with Linux in mind. The last straw was a table in &lt;a href=&quot;https://wiki.freebsd.org/arm/Raspberry%20Pi&quot;&gt;wiki&lt;/a&gt; which claims that the WiFi in Zero W is unsupported.&lt;br /&gt;
Going back to the Linux world, I still did not give up on using something different than &lt;del&gt;Raspbian&lt;/del&gt; Raspberry Pi OS. Looking for other options I stumbled across &lt;a href=&quot;https://archlinuxarm.org/&quot;&gt;Arch Linux ARM&lt;/a&gt;. I have never really used Arch before, so the feeling was similar as before. However, doubts started to arise - am I ready to take up all those hardships of learning different distro, hardware control and electronics all at once? Debian-based distros are familiar to me, so at least if matters go haywire I am not stuck fighting with a system, especially package manager.&lt;br /&gt;
Defeated, I started seeking &lt;del&gt;Raspbian&lt;/del&gt; Raspberry Pi OS derivatives that are not Raspberry Pi OS. From my earlier days of Raspberry Pi experiments I remembered &lt;a href=&quot;https://dietpi.com/&quot;&gt;DietPi&lt;/a&gt;, a lightweight spin on &lt;del&gt;Rasp&lt;/del&gt; Raspberry Pi OS with an optimized set of programs. I decided to give it a go, because it scratches that minimalist itch of mine.&lt;br /&gt;
The whole process of configuration is unremarkable. I flashed the SD card and edited the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diepi.txt&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dietpi-wifi.txt&lt;/code&gt; files to connect the Pi to the Internet on first boot, just as &lt;a href=&quot;https://dietpi.com/docs/install/&quot;&gt;instruction&lt;/a&gt; told me to. I then put the card in and proceeded to sweep the network in search of the device, so that I can connect through SSH and perform headless install. This process took longer than anticipated, because In my impatience I aborted the process several times thinking I missed something in the config. When I finally found the address, I connected and changed the passwords and such.&lt;/p&gt;

&lt;h1 id=&quot;environment&quot;&gt;Environment&lt;/h1&gt;

&lt;p&gt;Now that I had a working platform, I could start thinking about the software stuff.&lt;br /&gt;
In terms of my language of choice, I picked Rust - my new favorite toy in programming. Rust is well suited for embedded programming, and work with its package manager Cargo is a breeze.&lt;br /&gt;
In terms of gathering drivers and libraries, I began with epaper display. According to the &lt;a href=&quot;https://www.waveshare.com/wiki/7.5inch_e-Paper_HAT_Manual#Working_With_Raspberry_Pi&quot;&gt;wiki&lt;/a&gt; I had to enable SPI interface, which is hidden in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Advanced Options&lt;/code&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dietpi-config&lt;/code&gt;. Then I installed &lt;a href=&quot;https://www.airspayce.com/mikem/bcm2835/&quot;&gt;bcm2835 library&lt;/a&gt; used by Waveshare’s &lt;a href=&quot;https://github.com/waveshareteam/e-Paper&quot;&gt;demo code&lt;/a&gt;, which I might later cannibalize for screen control.&lt;br /&gt;
Button SHIM comes with a Python library. I refuse to use Python outside scientific work, and especially in low-level applications, so I started looking for Rust alternatives. I found something &lt;a href=&quot;https://github.com/mzyy94/buttonshim&quot;&gt;just for this purpose&lt;/a&gt; and thus looked no further.&lt;br /&gt;
To use the UPS HAT I just had to enable I&lt;sup&gt;2&lt;/sup&gt;C interface.&lt;/p&gt;

&lt;h1 id=&quot;testing-hardware&quot;&gt;Testing hardware&lt;/h1&gt;

&lt;h2 id=&quot;display&quot;&gt;Display&lt;/h2&gt;

&lt;p&gt;The first component I wanted to test was the epaper display. Thera are two ways of connecting it to the main board: the first and arguably the easiest is to put a HAT on Raspberry Pi, the more challenging way is to use the 8PIN cable that comes with the screen and manually plug in the cables onto header. For the purpose of checking if things are working all right I went the HAT way, because I do not want to risk frying the screen just yet. I connected the flat cables between boards and display and was ready to go.&lt;br /&gt;
The demo code I downloaded from Waveshare’s site is a bit messy, but as they stated somewhere in the files, that is because the library is written for all models they sell and writing redundant code would be pointless. Instead, provided Makefile composes the right demo for chosen display model during compilation. Per included readme, I executed:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# make EPD=epd7in5V2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Make created &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;epd&lt;/code&gt; executable in the working directory. When I ran it (with root), the display started flashing black and white and spat out different test pictures. I was quite impressed and satisfied with what I saw.
&lt;img src=&quot;/assets/images/postimages/rpiebook/workingepaper.jpg&quot; alt=&quot;working epaper display&quot; width=&quot;500&quot; class=&quot;center-image&quot; /&gt;
Epaper display - check!&lt;/p&gt;

&lt;h2 id=&quot;ups&quot;&gt;UPS&lt;/h2&gt;

&lt;p&gt;Raising difficulty bar by one level, I proceeded to test the power supply. I want to power my Pi with Akyga LiPol I purchased, which comes bundled with JST-BEC female connector with dangling cables for self-assembly. The board has no JST-BEC socket, but has two soldering pads for custom wiring. I proceeded to solder connector to the board. Whew! I get anxious when I solder so close to the delicate electronics, let alone power supply. Solders passed the test of strength, which made me glad.
&lt;img src=&quot;/assets/images/postimages/rpiebook/upssolders.jpg&quot; alt=&quot;beautiful job&quot; width=&quot;500&quot; class=&quot;center-image&quot; /&gt;
Look at these huge pins! Anyway, I put the HAT on Raspberry Pi and connected the battery. I clicked the button, the battery indicator on HAT flashed bright white and… nothing. I held the button a little longer, the battery indicator flashed bright white and… there it is! The Raspberry Pi green diode switched on. I successfully logged into Pi through SSH.
&lt;img src=&quot;/assets/images/postimages/rpiebook/upsworking.jpg&quot; alt=&quot;IT&apos;S WORKING!~Anakin Skywalker&quot; width=&quot;500&quot; class=&quot;center-image&quot; /&gt;
As I skimmed through the Net I read somewhere that the HAT allows for gentle shutdown when the battery is almost depleted, which is really nice.&lt;br /&gt;
UPS HAT - check! Moving on.&lt;/p&gt;

&lt;h2 id=&quot;buttons&quot;&gt;Buttons&lt;/h2&gt;

&lt;p&gt;The trickiest part to test was the button SHIM, because the only way to connect it is to solder it. As I stated in the previous post, I want it connected to the underside of Raspberry Pi. I do not know whether it is going to bite me in the bottom later, but now it seems to be a great idea. &lt;a href=&quot;https://pinout.xyz/pinout/button_shim&quot;&gt;pinout.xyz&lt;/a&gt; said I needed to solder pins 3, 4, 5, 6, 17. After I soldered everything I was mortified - I had it upside down! Thankfully I did not have to unsolder, just make more solders and this time in correct places.
&lt;img src=&quot;/assets/images/postimages/rpiebook/buttonssolders.jpg&quot; alt=&quot;had a little accident&quot; width=&quot;500&quot; class=&quot;center-image&quot; /&gt;
I know, they are not pretty, but I moved forward. As you can see, I tried to unsolder the wrong ones, but at the end of the day it does not matter. To test the buttons I had to set up Rust on my main machine to cross-compile to Raspberry Pi.&lt;/p&gt;

&lt;h1 id=&quot;rust-for-raspberry-pi&quot;&gt;Rust for Raspberry Pi&lt;/h1&gt;

&lt;p&gt;Setting up Rust and compiling on Pi would take too long to be worth it. To cross-compile from x86_64 machine to Raspberry Pi Zero W, first I had to add a new target:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rustup add target arm-unknown-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I had no luck with a toolchain provided by my distro’s repository, so I had to grab one from &lt;a href=&quot;https://github.com/raspberrypi/tools&quot;&gt;here&lt;/a&gt; and put it in my project directory under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rpi_tools&lt;/code&gt;. Then I created file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.cargo/config&lt;/code&gt; with the following contents:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[build]
[target.arm-unknown-linux-gnueabihf]
linker = &quot;rpi_tools/arm-bcm2708/arm-rpi-4.9.3-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this file I specified the custom linker I just downloaded. Rust is now ready to compile for Pi.&lt;/p&gt;

&lt;p&gt;To get a quick glance over the operation of SHIM I used the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rainbow.rs&lt;/code&gt; example included with mzyy94’s &lt;a href=&quot;https://github.com/mzyy94/buttonshim&quot;&gt;library&lt;/a&gt;. I compiled the file issuing:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cargo build --release --target=arm-unknown-linux-gnueabihf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scp&lt;/code&gt;‘d it to my Pi. The LED of Button SHIM changes color with button presses as intended.
&lt;img src=&quot;/assets/images/postimages/rpiebook/buttonsworking.jpg&quot; alt=&quot;colored lights&quot; width=&quot;500&quot; class=&quot;center-image&quot; /&gt;
Buttons - check!&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I managed to successfully test all hardware without problems. With Rust set up to producing ARM binaries I am ready to write software for this device.&lt;br /&gt;
In the next step I will be trying to make the display show whatever I order it to. I will also decide how I want to interact with the finished contraption, i.e. whether I should write a whole custom program a’la Kodi and encapsulate all functionality within it, or to make it more like a Linux box with access to the underlying OS.&lt;/p&gt;</content><author><name></name></author><category term="crafts" /><category term="electronics" /><category term="linux" /><summary type="html">With all the hardware onboard, it is time to see it in action. I have to test it before assembly.</summary></entry><entry><title type="html">DIY Raspberry Pi ebook reader, part 1 - acquiring hardware</title><link href="https://blamster19.github.io/2023/09/09/rpi-ebook-1.html" rel="alternate" type="text/html" title="DIY Raspberry Pi ebook reader, part 1 - acquiring hardware" /><published>2023-09-09T00:07:50+00:00</published><updated>2023-09-10T01:05:57+00:00</updated><id>https://blamster19.github.io/2023/09/09/rpi-ebook-1</id><content type="html" xml:base="https://blamster19.github.io/2023/09/09/rpi-ebook-1.html">&lt;h1 id=&quot;lets-build&quot;&gt;Let’s build&lt;/h1&gt;

&lt;p&gt;When I digged through ebook readers available on the market, it occured to me that every option is unappealing to me due to lack of customizability. Huge part of it lies in closed-source nature of those devices, which to me as an open source enthusiast is a major turn off. This, coupled with a hunk of free time during summer break, led me to the idea of building my own ebook reader. Happy with having a new project to hone my soldering skills, I enthusiastically set about making preparations.&lt;/p&gt;

&lt;h1 id=&quot;goals&quot;&gt;Goals&lt;/h1&gt;

&lt;p&gt;To instill some sense of direction into the project, I imagined it would be best to try and reach incremental goals. My first goal would be to connect every element one by one and check if every part works as intended. Next, a stage which will either make or break the whole endeavor, is to put everything together and make sure there are no conflicts between parts. And, for the last part, find some ebook software to actually use the thing, or, in the worst case, write one.&lt;/p&gt;

&lt;h1 id=&quot;the-innards&quot;&gt;The innards&lt;/h1&gt;

&lt;h2 id=&quot;core&quot;&gt;Core&lt;/h2&gt;

&lt;p&gt;I want my contraption to be both functional and similar in form to commercial counterparts. It has to be lightweight and handy, while allowing a degree of flexibility in customization. Since I have no infrastracture, means and skills to manufacture custom boards, I am bound to SBCs, which is not at all bad considering saved money and time. Ebook, like tablet or smartphone, is rather slim, which means very limited range of connection ports. There is no space and energy to spare for active cooling, so the chip has to run cold. Frankly, it does not have to be as powerful as aforementioned devices, because its primary purpose is to print text. Taking all that into consideration my vote went to &lt;a href=&quot;https://www.raspberrypi.com/products/raspberry-pi-zero-w/&quot;&gt;Raspberry Pi Zero W&lt;/a&gt;. Arguments for this pick were my familiarity with Raspberry Pis, wealth of documentation and code, a range of ready-made extensions and ease of use. Integrated Wi-Fi allows for smooth hassle-free software deployment while also being a nice feature of the finished project. Model Zero is also much thinner and energy efficient than its full-sized siblings, making it a perfect fit for my application. Another chief asset of Zero is that it is powerful just enough to run a full Linux distribution, so no need to play with low level embedded. I would gladly take version 2, but sadly, they were out of order wherever I looked, and summer break is too short to wait. For convenience, I settled for Raspberry Pi Zero WH, with soldered header.&lt;/p&gt;

&lt;h2 id=&quot;power&quot;&gt;Power&lt;/h2&gt;

&lt;p&gt;Much to nobody’s surprise, there are myriad ways to power Raspberry Pi. Obviously, battery power is the only sensible choice, but even that can be done in many ways.&lt;br /&gt;
The most barebones solution is to construct appropriate circuit and plug in the source. The upside of it is being able to custom tailor every aspect of power supply. The downside is required knowledge and ease of screwing things up. I never feel confident enough in my tinkering abilities when it comes to powering things, so I immediately discarded this option.&lt;br /&gt;
Another popular solution is to cannibalise power bank. This is handy, as powerbanks come with charging module, so you just plug in the cable and you are set. However, powerbanks are often a little bulky and poorly regulated, which would cause a lot of random restarts upon voltage drops. After all, they are meant to store energy, not act as a power supply, so manufacturers could not care less about stability. Another missing thing is feedback - powerbanks do not return their status to devices they power, so going below certain threshold would always cause abrupt shutdown and, over time, murder the SBC.&lt;br /&gt;
This leads me to the third option, which is dedicated Raspberry Pi power supply board. These little circuits provide stable voltage, have integrated charger, output battery level and play nicely with Pi, due to the whole &lt;a href=&quot;https://www.raspberrypi.com/news/introducing-raspberry-pi-hats/&quot;&gt;HAT&lt;/a&gt; design which enables stacking of extension boards.&lt;br /&gt;
After quite some time spent on researching the topic and looking through offers I chose &lt;a href=&quot;https://wiki.dfrobot.com/UPS%20HAT%20for%20Raspberry%20Pi%20%20Zero%20%20SKU%3A%20DFR0528&quot;&gt;DFRobot DFR0528 UPS HAT&lt;/a&gt;. It fulfills all my requirements, is quite cheap and available. The official wiki seems to nicely explain how to enable battery level reading.&lt;/p&gt;

&lt;p&gt;When it comes to power source, the obvious choice would be either Li-Ion or Li-Pol battery. I wanted something thin, light and capacious, so I chose Li-Pol Akyga 3500 mAh 1S 3,7 V which I found in local eshop. The battery comes with connector cable ready to be soldered to UPS HAT.&lt;/p&gt;

&lt;h2 id=&quot;screen&quot;&gt;Screen&lt;/h2&gt;

&lt;p&gt;From the beginning it was clear that I want e-paper dispay. E-paper is easy on eyes, legible in sunlight, extremely power efficient and looks cool. In this day and age there is an array of different sizes of e-papers made for Raspberry Pi. Since I want to build a reader, I need quite a lot of surface area, but the bigger the surface, the slower the refresh rate. This is further exacerbated when different colors come into play, where refresh procedure can take up to thirty seconds. This is unacceptable to me, so I decided I am content with fast but b/w display. Finally, I found a nice compromise, &lt;a href=&quot;https://www.waveshare.com/7.5inch-e-Paper-HAT.htm&quot;&gt;Waveshare 800x480 7.5inch E-Ink Display&lt;/a&gt; which comes with a HAT. The screen communicates through SPI, has a refresh rate of 5 s, resolution of 800 by 480 pixels and dimensions of 163,2 by 97,92 mm.&lt;/p&gt;

&lt;h2 id=&quot;buttons&quot;&gt;Buttons&lt;/h2&gt;

&lt;p&gt;I almost forgot that in order to actually do stuff with my ebook, I need to control it somehow. For a while I thought I would build something from parts from my local (and physical) shop, until I found &lt;a href=&quot;https://shop.pimoroni.com/products/button-shim&quot;&gt;Pimoroni Button SHIM&lt;/a&gt;, which seems perfect for my use case.&lt;/p&gt;

&lt;h1 id=&quot;the-design&quot;&gt;The design&lt;/h1&gt;

&lt;p&gt;This project takes on highly experimental approach, and I am not much of a planner when it comes to those things. I very much like to get my hands dirty first and construct something that works, then worry about the details (like how to actually put the parts in place). However, perhaps, if I want to write a few blog posts about my adventure, then the usual way of doing things is not very good for that. I should pave a roadmap and pull together some kind of schematic. Without further ado I fired up Blender and made models of my parts.&lt;br /&gt;
&lt;img src=&quot;/assets/images/postimages/rpiebook/parts3d.png&quot; alt=&quot;3D parts one after another&quot; width=&quot;500&quot; class=&quot;center-image&quot; /&gt;
The first thing that is striking is that UPS HAT’s pins are huge, sprouting 1 cm from both sides. This is non-ideal in my case, so I will have to unsolder that thing or find another way to slim down the board.&lt;br /&gt;
While the idea of HATs is amazing in its own right, stacking just one extension board on top of Pi makes the whole setup really thick. Luckily, every board uses just a few pins from the whole header, so the idea to connect appropriate pins with cables and position all boards horizontally is not completely bonkers. To further slim down the setup and to get better access to Pi pins, I chose to solder button SHIM to the underside. I had to keep all boards with buttons and ports at the edge and also remember not to strain the FFC cable too much. Taking all that into consideration I attempted to make a draft in Blender and am pretty happy with the looks of it.&lt;br /&gt;
&lt;img src=&quot;/assets/images/postimages/rpiebook/layout3d.png&quot; alt=&quot;3D parts one after another&quot; width=&quot;500&quot; class=&quot;center-image&quot; /&gt;&lt;br /&gt;
The layout feels a bit off, because Raspberry Pi with its button shim are positioned to align the middle button with the center of the screen; likewise, e-paper connector is aligned with screen tape at the top (not rendered).&lt;/p&gt;

&lt;h1 id=&quot;closing-remarks&quot;&gt;Closing remarks&lt;/h1&gt;

&lt;p&gt;After fruitful team participation in robot competition I felt like taking up a solo project this time. I wanted to actually learn the process of doing project from start to finish, but now on my own terms. Ebook reader involves just a few parts, does not require much soldering, and poses a great opportunity to get a hands-on experience in electronics.&lt;br /&gt;
In the next step I will install and configure the OS, set up development environment, install necessary libraries and test all acquired boards.&lt;/p&gt;</content><author><name></name></author><category term="crafts" /><category term="electronics" /><summary type="html">Best personal projects are the projects which later serve a purpose. Ebook reader strikes me as the best balance of ease and utility.</summary></entry></feed>